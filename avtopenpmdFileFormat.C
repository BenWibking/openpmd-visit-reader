// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtopenpmdFileFormat.C
// ****************************************************************************

#include <algorithm>
#include <cstddef>
#include <iostream>
#include <string>

#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUniformGrid.h>
#include <vtkUnstructuredGrid.h>

#include <openPMD/openPMD.hpp>

#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include <Expression.h>
#include <InvalidVariableException.h>

#include "avtopenpmdFileFormat.h"

// ****************************************************************************
//  Method: avtopenpmdFileFormat constructor
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

avtopenpmdFileFormat::avtopenpmdFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1) {
  //
  // initialize an openPMD::series object
  //

  // read incomplete filepath string from file 'filename'
  std::string opmd_filestring;
  {
    std::ifstream file(filename);
    std::getline(file, opmd_filestring);
    file.close();
  }

  // construct complete filepath
  std::filesystem::path p(filename);
  std::string os_pathsep = "/";
  std::string parent_path = p.parent_path();
  std::string opmd_filepath = parent_path + os_pathsep + opmd_filestring;
  debug5 << "Reading OpenPMD series: " << opmd_filepath << "\n";

  // open openPMD series
  series_ = openPMD::Series(opmd_filepath, openPMD::Access::READ_ONLY);
  debug5 << "This file uses openPMD-standard version " << series_.openPMD()
         << '\n';

  // read iteration count
  debug5 << "This file contains " << series_.iterations.size()
         << " iterations:";
  iterationIndex_ = std::vector<unsigned long long>(series_.iterations.size());

  // save map from timeState to iteration index
  // NOTE: openPMD's iteration index can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  int timeState = 0;
  for (auto const &iter : series_.iterations) {
    debug5 << "\n\t" << iter.first;
    iterationIndex_.at(timeState) = iter.first;
    timeState++;
  }
  debug5 << '\n';
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

int avtopenpmdFileFormat::GetNTimesteps(void) {
  return series_.iterations.size();
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::FreeUpResources(void) {}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md,
                                                    int timeState) {
  // NOTE: openPMD's iteration index 'iter' can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  unsigned long long iter = iterationIndex_.at(timeState);
  debug5 << "PopulateDatabaseMetaData() for iteration " << iter << "\n";

  // open openPMD::Iteration 'iter'
  openPMD::Iteration i = series_.iterations[iter];

  // NOTE: a good reference for understanding how to read OpenPMD files is:
  // https://github.com/openPMD/openPMD-api/blob/dev/examples/6_dump_filebased_series.cpp

  // loop over openPMD::Mesh objects
  debug5 << "Iteration " << iter << " contains " << i.meshes.size()
         << " meshes:\n";

  for (auto const &mesh_tuple : i.meshes) {
    std::string meshname = mesh_tuple.first;
    openPMD::Mesh mesh = mesh_tuple.second;
    debug5 << "Reading mesh " << meshname << "\n";

    avtMeshType mt = AVT_RECTILINEAR_MESH;
    int nblocks = 1; // <-- this must be 1 for MTSD
    int block_origin = 0;
    int spatial_dimension = mesh.axisLabels().size();
    int topological_dimension = spatial_dimension;
    double *extents = NULL;

    AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
                      spatial_dimension, topological_dimension);

    // Each openPMD::Mesh may contain one or more openPMD::MeshRecordComponent
    // A MeshRecordComponent is either i) a scalar, or ii) a vector component

    if (mesh.scalar()) { // this openPMD::Mesh contains only one
                         // MeshRecordComponent
      // when there is only one MeshRecordComponent, the name of the variable
      // should be the same as the Mesh
      debug5 << "Adding scalar variable " << meshname << "\n";

      // TODO: read the centering from attributes
      // NOTE: OpenPMD allows for arbitrary centering. Components can be face-
      // or edge-centered! VisIt centerings: AVT_NODECENT, AVT_ZONECENT,
      // AVT_UNKNOWN_CENT
      avtCentering cent = AVT_ZONECENT;

      AddScalarVarToMetaData(md, meshname, meshname, cent);

    } else { // this openPMD::Mesh contains multiple MeshRecordComponent's
      // NOTE: this object MAY or MAY NOT make sense to treat as a vector.
      // It probably makes more sense to enroll multiple scalar variables, one
      // per MeshRecordComponent, and let the user create a vector with
      // expressions, if appropriate for the dataset.

      for (auto const &rc : mesh) {
        // when there are multiple components, we create a hierarchical dataset
        std::string varname = meshname + std::string("/") + rc.first;
        debug5 << "Adding scalar variable " << varname << "\n";

        // TODO: read the centering from attributes
        // NOTE: OpenPMD allows for arbitrary centering. Components can be face-
        // or edge-centered! VisIt centerings: AVT_NODECENT, AVT_ZONECENT,
        // AVT_UNKNOWN_CENT
        avtCentering cent = AVT_ZONECENT;

        AddScalarVarToMetaData(md, varname, meshname, cent);
      }
    }
  }
  debug5 << '\n' << '\n';
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and
//                  N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataSet *avtopenpmdFileFormat::GetMesh(int timeState, const char *meshname) {
  // get actual iteration index
  unsigned long long iter = iterationIndex_.at(timeState);
  debug5 << "GetMesh() for iteration " << iter << " and mesh " << meshname
         << "\n";

  // open openPMD::Iteration 'iter' and openPMD::Mesh 'mesh'
  openPMD::Iteration i = series_.iterations[iter];
  openPMD::Mesh mesh = i.meshes[meshname];

  // check that this is a cartesian mesh
  if (mesh.geometry() != openPMD::Mesh::Geometry::cartesian) {
    debug5 << "Unknown openPMD::Mesh geometry. Must be cartesian!\n";
    return 0;
  }

  // openPMD geometry
  const int ndims = mesh.axisLabels().size();
  std::vector<double> gridSpacing = mesh.gridSpacing<double>();
  std::vector<double> gridOrigin = mesh.gridGlobalOffset();
  std::vector<std::uint64_t> gridExtent = mesh.getExtent();

  // NOTE: VTK arrays are in Fortran order:
  // "VTK image data arrays are stored such that the X dimension increases
  // fastest, followed by Y, followed by Z."
  // (https://public.kitware.com/pipermail/vtkusers/2016-September/096626.html)
  // Instead of re-ordering the array, we just flip the axisLabels as needed.
  if (mesh.dataOrder() == openPMD::Mesh::DataOrder::C) {
    std::reverse(gridSpacing.begin(), gridSpacing.end());
    std::reverse(gridOrigin.begin(), gridOrigin.end());
    std::reverse(gridExtent.begin(), gridExtent.end());
  }

  // VTK geometry
  double origin[3] = {0, 0, 0};  // position x0, y0, z0
  double spacing[3] = {0, 0, 0}; // dx, dy, dz
  int dims[3] = {1, 1, 1};       // number of cells + 1

  for (int idim = 0; idim < ndims; ++idim) {
    origin[idim] = gridOrigin[idim];
    spacing[idim] = gridSpacing[idim];
    dims[idim] = static_cast<int>(gridExtent[idim]) + 1;
  }

  // debugging output
  std::string meshPrefix = std::to_string(iter) + '.' + meshname;
  std::string axisLabels = "";
  for (auto const &val : mesh.axisLabels())
    axisLabels += val + ", ";
  std::string gridSpacing_str = "";
  for (auto const &val : mesh.gridSpacing<float>())
    gridSpacing_str += std::to_string(val) + ", ";
  std::string gridGlobalOffset = "";
  for (auto const &val : mesh.gridGlobalOffset())
    gridGlobalOffset += std::to_string(val) + ", ";
  std::string gridExtent_str = "";
  for (auto const &val : mesh.getExtent())
    gridExtent_str += std::to_string(val) + ", ";

  debug5 << meshPrefix << ".geometry - " << mesh.geometry() << '\n'
         << meshPrefix << ".dataOrder - " << mesh.dataOrder() << '\n'
         << meshPrefix << ".axisLabels - " << axisLabels << '\n'
         << meshPrefix << ".gridSpacing - " << gridSpacing_str << '\n'
         << meshPrefix << ".gridGlobalOffset - " << gridGlobalOffset << '\n'
         << meshPrefix << ".getExtent - " << gridExtent_str << '\n'
         << '\n'
         << '\n';

  // TODO(benwibking): loop over chunks and create separate vtkUniformGrids for
  // each chunk and assemble into an AMR mesh.
  // This is necessary for files with sparse grids (also used for AMR datasets).

  vtkFloatArray *coords[3];
  for (int idim = 0; idim < 3; ++idim) {
    coords[idim] = vtkFloatArray::New();
    // initialize with null values
    coords[idim]->SetNumberOfTuples(1);
    coords[idim]->SetComponent(0, 0, 0.);
  }

  // loop over real dimensions
  for (int idim = 0; idim < ndims; ++idim) {
    coords[idim]->SetNumberOfTuples(dims[idim]);
    float *array = static_cast<float *>(coords[idim]->GetVoidPointer(0));
    // set rectilinear coordinates at nodes of grid
    for (int idx = 0; idx <= dims[idim]; ++idx) {
      array[idx] = idx * spacing[idim] + origin[idim];
    }
  }

  vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
  rgrid->SetDimensions(dims);
  rgrid->SetXCoordinates(coords[0]);
  rgrid->SetYCoordinates(coords[1]);
  rgrid->SetZCoordinates(coords[2]);

  for (int idim = 0; idim < 3; ++idim) {
    coords[idim]->Delete();
  }

  return rgrid;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVar(int timeState, const char *varname) {
  // get actual iteration index
  unsigned long long iter = iterationIndex_.at(timeState);
  debug5 << "GetVar() for iteration " << iter << " and var " << varname
         << std::endl;

  // lookup mesh name and record component name from varname
  // TODO: implement this
  std::string meshname = varname;
  const char *rcname =
      openPMD::Mesh::MeshRecordComponent::SCALAR; // FIXME: assumes a scalar
                                                  // mesh

  // open openPMD::Iteration 'iter' and openPMD::Mesh 'mesh'
  openPMD::Iteration i = series_.iterations[iter];
  openPMD::Mesh mesh = i.meshes[meshname];
  openPMD::MeshRecordComponent rcomp = mesh[rcname];

  // get geometry
  std::vector<std::uint64_t> gridExtent = rcomp.getExtent();

  // NOTE: VTK arrays are in Fortran order:
  // "VTK image data arrays are stored such that the X dimension increases
  // fastest, followed by Y, followed by Z."
  // (https://public.kitware.com/pipermail/vtkusers/2016-September/096626.html)
  // Instead of re-ordering the array, we just flip the axisLabels as needed.
  if (mesh.dataOrder() == openPMD::Mesh::DataOrder::C) {
    std::reverse(gridExtent.begin(), gridExtent.end());
  }

  // get number of cells
  uint64_t ncells = 1;
  for (auto const &nx : gridExtent) {
    ncells *= nx;
  }

  // create VTK buffer
  // TODO: need to support either float or double
  vtkDoubleArray *xyz = vtkDoubleArray::New();
  xyz->SetNumberOfComponents(1);
  xyz->SetNumberOfTuples(ncells);
  double *xyz_ptr = xyz->GetPointer(0);

  // read data from disk into VTK buffer
  // set offset and extent are set to read the full array
  rcomp.loadChunkRaw(xyz_ptr, {0U}, {-1U});
  series_.flush(); // this actually reads the data

  return xyz;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVectorVar(int timestate,
                                                 const char *varname) {
  return 0;
}
