// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtopenpmdFileFormat.C
// ****************************************************************************

#include <algorithm>
#include <cstddef>
#include <iostream>
#include <stdexcept>
#include <string>

#include <avtDatabaseMetaData.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>

#include <openPMD/openPMD.hpp>

#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include <Expression.h>
#include <InvalidVariableException.h>

#include "avtopenpmdFileFormat.h"

// ****************************************************************************
//  Method: avtopenpmdFileFormat constructor
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

avtopenpmdFileFormat::avtopenpmdFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1) {
  //
  // initialize an openPMD::series object
  //

  // read incomplete filepath string from file 'filename'
  std::string opmd_filestring;
  {
    std::ifstream file(filename);
    std::getline(file, opmd_filestring);
    file.close();
  }

  // construct complete filepath
  std::filesystem::path p(filename);
  std::string os_pathsep = "/";
  std::string parent_path = p.parent_path();
  std::string opmd_filepath = parent_path + os_pathsep + opmd_filestring;
  debug5 << "[openpmd-api-plugin] "
         << "Reading OpenPMD series: " << opmd_filepath << "\n";

  // open openPMD series
  series_ = openPMD::Series(opmd_filepath, openPMD::Access::READ_ONLY);
  debug5 << "[openpmd-api-plugin] "
         << "This file uses openPMD-standard version " << series_.openPMD()
         << '\n';

  // read iteration count
  debug5 << "[openpmd-api-plugin] "
         << "This file contains " << series_.iterations.size()
         << " iterations:";
  iterationIndex_ = std::vector<unsigned long long>(series_.iterations.size());

  // save map from timeState to iteration index
  // NOTE: openPMD's iteration index can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  int timeState = 0;
  for (auto const &iter : series_.iterations) {
    debug5 << "\n\t" << iter.first;
    iterationIndex_.at(timeState) = iter.first;
    timeState++;
  }
  debug5 << '\n';
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

int avtopenpmdFileFormat::GetNTimesteps(void) {
  return series_.iterations.size();
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::FreeUpResources(void) {}

template <typename T>
avtCentering avtopenpmdFileFormat::GetCenteringType(T const &mesh) {
  // read the element centering
  std::vector<float> centering;
  try {
    centering = mesh.template position<float>();
  } catch (openPMD::Error) {
    debug5 << "[openpmd-api-plugin] "
           << "Can't read centering for mesh!\n";
    return AVT_UNKNOWN_CENT;
  }

  // cell-centered == {0.5, 0.5, 0.5}
  bool isCellCentered = true;
  for (int idim = 0; idim < centering.size(); idim++) {
    isCellCentered = (isCellCentered && (centering[idim] == 0.5));
  }

  // node-centered == {0, 0, 0}
  bool isNodeCentered = true;
  for (int idim = 0; idim < centering.size(); idim++) {
    isNodeCentered = (isNodeCentered && (centering[idim] == 0.));
  }

  if (isCellCentered) {
    debug5 << "[openpmd-api-plugin] "
           << "Mesh is cell-centered.\n";
    return AVT_ZONECENT;
  } else if (isNodeCentered) {
    debug5 << "[openpmd-api-plugin] "
           << "Mesh is node-centered.\n";
    return AVT_NODECENT;
  }

  // face-centered == {0, 0.5, 0.5}, etc.
  // edge-centered == {0, 0, 0.5}, etc.
  // However, all other centerings are unsupported by VisIt.
  debug5 << "[openpmd-api-plugin] "
         << "Mesh has unsupported centering.\n";
  return AVT_UNKNOWN_CENT;
}

void avtopenpmdFileFormat::ReadFieldMetaData(avtDatabaseMetaData *md,
                                             openPMD::Iteration const &i) {
  // NOTE: a good reference for understanding how to read OpenPMD files is:
  // https://github.com/openPMD/openPMD-api/blob/dev/examples/6_dump_filebased_series.cpp

  // loop over openPMD::Mesh objects
  debug5 << "[openpmd-api-plugin] "
         << "This iteration contains " << i.meshes.size() << " meshes:\n";

  for (auto const &mesh_tuple : i.meshes) {
    std::string openpmd_meshname = mesh_tuple.first;
    std::string visit_meshname = openpmd_meshname + "_mesh";
    
    openPMD::Mesh mesh = mesh_tuple.second;
    debug5 << "[openpmd-api-plugin] "
           << "Reading mesh " << openpmd_meshname << "\n";

    avtMeshType mt = AVT_RECTILINEAR_MESH;
    int nblocks = 1; // <-- this must be 1 for MTSD
    int block_origin = 0;
    int spatial_dimension = mesh.axisLabels().size();
    int topological_dimension = spatial_dimension;
    double *extents = NULL;

    meshMap_[visit_meshname] = std::tuple(DatasetType::Field, openpmd_meshname);
    AddMeshToMetaData(md, visit_meshname, mt, extents, nblocks, block_origin,
                      spatial_dimension, topological_dimension);

    // Each openPMD::Mesh may contain one or more openPMD::MeshRecordComponent
    // A MeshRecordComponent is either i) a scalar, or ii) a vector component

    if (mesh.scalar()) {
      // this openPMD::Mesh contains only one MeshRecordComponent when there is
      // only one MeshRecordComponent, the name of the variable should be the
      // same as the Mesh
      std::string varname = openpmd_meshname;

      // read the element centering
      avtCentering cent = GetCenteringType<openPMD::Mesh>(mesh);

      // add var
      if (cent != AVT_UNKNOWN_CENT) {
        debug5 << "[openpmd-api-plugin] "
               << "Adding scalar variable " << varname << "\n";
        std::string openpmd_compname = openPMD::MeshRecordComponent::SCALAR;
        varMap_[varname] = std::tuple(openpmd_meshname, openpmd_compname);
        AddScalarVarToMetaData(md, varname, visit_meshname, cent);
      } else {
        debug5 << "[openpmd-api-plugin] "
               << "Var " << varname
               << " is not cell/node-centered, skipping.\n";
      }
    } else { // this openPMD::Mesh contains multiple 'MeshRecordComponent's
      // It probably makes more sense to enroll multiple scalar variables, one
      // per MeshRecordComponent, and let the user create a vector with
      // expressions, if appropriate for the dataset.

      for (auto const &rc : mesh) {
        // when there are multiple components, we create a hierarchical dataset
        std::string openpmd_compname = rc.first;
        std::string varname =
            openpmd_meshname + std::string("/") + openpmd_compname;

        // read the element centering
        avtCentering cent =
            GetCenteringType<openPMD::MeshRecordComponent>(rc.second);

        // add var
        if (cent != AVT_UNKNOWN_CENT) {
          debug5 << "[openpmd-api-plugin] "
                 << "Adding scalar variable " << varname << "\n";
          varMap_[varname] = std::tuple(openpmd_meshname, openpmd_compname);
          AddScalarVarToMetaData(md, varname, visit_meshname, cent);
        } else {
          debug5 << "[openpmd-api-plugin] "
                 << "Var " << varname
                 << " is not cell/node-centered, skipping.\n";
        }
      }
    }
  }
  debug5 << '\n' << '\n';
}

void avtopenpmdFileFormat::ReadParticleMetaData(avtDatabaseMetaData *md,
                                                openPMD::Iteration const &i) {
  // NOTE: a good reference for understanding how to read OpenPMD files is:
  // https://github.com/openPMD/openPMD-api/blob/dev/examples/6_dump_filebased_series.cpp

  // loop over openPMD::ParticleSpecies objects
  debug5 << "[openpmd-api-plugin] "
         << "This iteration contains " << i.particles.size()
         << " particle species:\n";

  for (auto const &particle_tuple : i.particles) {
    std::string openpmd_speciesname = particle_tuple.first;
    std::string visit_meshname = openpmd_speciesname + "_particles";

    openPMD::ParticleSpecies species = particle_tuple.second;
    debug5 << "[openpmd-api-plugin] "
           << "Reading particle species " << openpmd_speciesname << "\n";

    meshMap_[visit_meshname] =
        std::tuple(DatasetType::ParticleSpecies, openpmd_speciesname);
    avtMeshMetaData *mmd =
        new avtMeshMetaData(visit_meshname, 1, 0, 0, 0, 3, 1, AVT_POINT_MESH);
    mmd->nodesAreCritical = true;
    md->Add(mmd);
  }
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md,
                                                    int timeState) {
  // NOTE: openPMD's iteration index 'iter' can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  unsigned long long iterIdx = iterationIndex_.at(timeState);
  debug5 << "[openpmd-api-plugin] "
         << "PopulateDatabaseMetaData() for iteration " << iterIdx << "\n";

  // open openPMD::Iteration 'iter'
  openPMD::Iteration iter = series_.iterations[iterIdx];

  // read fields
  ReadFieldMetaData(md, iter);

  // read particles
  ReadParticleMetaData(md, iter);
}

vtkDataSet *avtopenpmdFileFormat::GetMeshField(openPMD::Iteration i,
                                               std::string const &meshname) {
  // open openPMD::Mesh 'meshname'
  openPMD::Mesh mesh = i.meshes[meshname];

  // check that this is a cartesian mesh
  if (mesh.geometry() != openPMD::Mesh::Geometry::cartesian) {
    debug5 << "[openpmd-api-plugin] "
           << "Unknown openPMD::Mesh geometry. Must be cartesian!\n";
    return 0;
  }

  // openPMD geometry
  const int ndims = mesh.axisLabels().size();
  std::vector<double> gridSpacing = mesh.gridSpacing<double>();
  std::vector<double> gridOrigin = mesh.gridGlobalOffset();
  std::vector<std::uint64_t> gridExtent = mesh.getExtent();

  // NOTE: VTK arrays are in Fortran order:
  // "VTK image data arrays are stored such that the X dimension increases
  // fastest, followed by Y, followed by Z."
  // (https://public.kitware.com/pipermail/vtkusers/2016-September/096626.html)
  // Instead of re-ordering the array, we just flip the axisLabels as needed.
  if (mesh.dataOrder() == openPMD::Mesh::DataOrder::C) {
    std::reverse(gridSpacing.begin(), gridSpacing.end());
    std::reverse(gridOrigin.begin(), gridOrigin.end());
    std::reverse(gridExtent.begin(), gridExtent.end());
  }

  // VTK geometry
  double origin[3] = {0, 0, 0};  // position x0, y0, z0
  double spacing[3] = {0, 0, 0}; // dx, dy, dz
  int dims[3] = {1, 1, 1};       // number of cells + 1
  avtCentering cent = GetCenteringType<openPMD::Mesh>(mesh);

  for (int idim = 0; idim < ndims; ++idim) {
    origin[idim] = gridOrigin[idim];
    spacing[idim] = gridSpacing[idim];
    if (cent == AVT_ZONECENT) {
      dims[idim] = static_cast<int>(gridExtent[idim]) + 1;
    } else if (cent == AVT_NODECENT) {
      dims[idim] = static_cast<int>(gridExtent[idim]);
    }
  }

  // debugging output
  std::string meshPrefix = meshname;
  std::string axisLabels = "";
  for (auto const &val : mesh.axisLabels())
    axisLabels += val + ", ";
  std::string gridSpacing_str = "";
  for (auto const &val : mesh.gridSpacing<float>())
    gridSpacing_str += std::to_string(val) + ", ";
  std::string gridGlobalOffset = "";
  for (auto const &val : mesh.gridGlobalOffset())
    gridGlobalOffset += std::to_string(val) + ", ";
  std::string gridExtent_str = "";
  for (auto const &val : mesh.getExtent())
    gridExtent_str += std::to_string(val) + ", ";

  debug5 << "[openpmd-api-plugin] " << meshPrefix << ".geometry - "
         << mesh.geometry() << '\n'
         << meshPrefix << ".dataOrder - " << mesh.dataOrder() << '\n'
         << meshPrefix << ".axisLabels - " << axisLabels << '\n'
         << meshPrefix << ".gridSpacing - " << gridSpacing_str << '\n'
         << meshPrefix << ".gridGlobalOffset - " << gridGlobalOffset << '\n'
         << meshPrefix << ".getExtent - " << gridExtent_str << '\n'
         << '\n'
         << '\n';

  // TODO(benwibking): loop over chunks and create separate vtkUniformGrids
  // for each chunk and assemble into an AMR mesh. This is necessary for files
  // with sparse grids (also used for AMR datasets).

  vtkFloatArray *coords[3];
  for (int idim = 0; idim < 3; ++idim) {
    coords[idim] = vtkFloatArray::New();
    // initialize with null values
    coords[idim]->SetNumberOfTuples(1);
    coords[idim]->SetComponent(0, 0, 0.);
  }

  // loop over real dimensions
  for (int idim = 0; idim < ndims; ++idim) {
    coords[idim]->SetNumberOfTuples(dims[idim]);
    float *array = static_cast<float *>(coords[idim]->GetVoidPointer(0));
    // set rectilinear coordinates at nodes of grid
    for (int idx = 0; idx <= dims[idim]; ++idx) {
      array[idx] = idx * spacing[idim] + origin[idim];
    }
  }

  vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
  rgrid->SetDimensions(dims);
  rgrid->SetXCoordinates(coords[0]);
  rgrid->SetYCoordinates(coords[1]);
  rgrid->SetZCoordinates(coords[2]);

  for (int idim = 0; idim < 3; ++idim) {
    coords[idim]->Delete();
  }

  return rgrid;
}

vtkDataSet *
avtopenpmdFileFormat::GetMeshParticles(openPMD::Iteration i,
                                       std::string const &meshname) {
  // open openPMD::ParticleSpecies 'meshname'
  openPMD::ParticleSpecies species = i.particles[meshname];

  // read column-wise particle positions and offsets
  std::vector<float> x(species.size());
  std::vector<float> y(species.size());
  std::vector<float> z(species.size());
  std::vector<float> xoff(species.size());
  std::vector<float> yoff(species.size());
  std::vector<float> zoff(species.size());

  for (auto [comp, pos, pos_offset] :
       {std::tuple("x", x, xoff), std::tuple("y", x, yoff),
        std::tuple("z", x, zoff)}) {
    // read positions
    {
      std::string recordname = "position/" + std::string(comp);
      try {
        openPMD::Record rc = species[recordname];
        rc.loadChunkRaw(pos.data(), {0U}, {-1U});
      } catch (std::out_of_range) {
        debug5 << "[openpmd-api-plugin] " << recordname << " does not exist!\n";
        pos.resize(0);
      }
    }
    // read offsets
    {
      std::string recordname = "positionOffset/" + std::string(comp);
      try {
        openPMD::Record rc_offset = species[recordname];
        rc_offset.loadChunkRaw(pos_offset.data(), {0U}, {-1U});
      } catch (std::out_of_range) {
        debug5 << "[openpmd-api-plugin] " << recordname << " does not exist!\n";
        pos_offset.resize(0);
      }
    }
  }

  vtkPolyData *pd = vtkPolyData::New();
  vtkPoints *pts = vtkPoints::New();
  pts->SetNumberOfPoints(x.size());
  pd->SetPoints(pts);
  pts->Delete();

  for (int j = 0; j < x.size(); j++) {
    // TODO(benwibking): positions and positionOffsets may have different units!
    // need to fix.
    float this_x = x.at(j) + xoff.at(j);
    float this_y = y.at(j) + yoff.at(j);
    float this_z = z.at(j) + zoff.at(j);
    pts->SetPoint(j, this_x, this_y, this_z);
  }

  vtkCellArray *verts = vtkCellArray::New();
  pd->SetVerts(verts);
  verts->Delete();

  for (int k = 0; k < x.size(); k++) {
    verts->InsertNextCell(1);
    verts->InsertCellPoint(k);
  }

  return pd;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and
//                  N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataSet *avtopenpmdFileFormat::GetMesh(int timeState,
                                          const char *visit_meshname) {
  // get actual iteration index
  unsigned long long iter = iterationIndex_.at(timeState);

  debug5 << "[openpmd-api-plugin] "
         << "GetMesh() for iteration " << iter << " and VisIt mesh "
         << visit_meshname << "\n";

  // open openPMD::Iteration 'iter'
  openPMD::Iteration i = series_.iterations[iter];

  // get actual meshname
  auto [dataset_type, meshname] = meshMap_[visit_meshname];

  if (dataset_type == DatasetType::Field) {
    return GetMeshField(i, meshname);
  } else if (dataset_type == DatasetType::ParticleSpecies) {
    return GetMeshParticles(i, meshname);
  }

  return 0;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVar(int timeState, const char *varname) {
  // get actual iteration index
  unsigned long long iter = iterationIndex_.at(timeState);

  // lookup openPMD mesh name and record component name from varname
  auto [meshname, rcname] = varMap_[varname];

  debug5 << "[openpmd-api-plugin] "
         << "GetVar() for iteration " << iter << " and var " << varname
         << std::endl;

  // open openPMD::Iteration 'iter' and openPMD::Mesh 'mesh'
  openPMD::Iteration i = series_.iterations[iter];
  openPMD::Mesh mesh = i.meshes[meshname];
  openPMD::MeshRecordComponent rcomp = mesh[rcname];

  // get geometry
  std::vector<std::uint64_t> gridExtent = rcomp.getExtent();

  // NOTE: VTK arrays are in Fortran order:
  // "VTK image data arrays are stored such that the X dimension increases
  // fastest, followed by Y, followed by Z."
  // (https://public.kitware.com/pipermail/vtkusers/2016-September/096626.html)
  // Instead of re-ordering the array, we just flip the axisLabels as needed.
  if (mesh.dataOrder() == openPMD::Mesh::DataOrder::C) {
    std::reverse(gridExtent.begin(), gridExtent.end());
  }

  // get number of elements
  uint64_t nelem = 1;
  for (auto const &nx : gridExtent) {
    nelem *= nx;
  }

  if (rcomp.getDatatype() == openPMD::Datatype::DOUBLE) {
    // create VTK buffer
    vtkDoubleArray *xyz_double = vtkDoubleArray::New();
    xyz_double->SetNumberOfComponents(1);
    xyz_double->SetNumberOfTuples(nelem);
    double *xyz_ptr = xyz_double->GetPointer(0);

    // set offset and extent are set to read the full array
    rcomp.loadChunkRaw(xyz_ptr, {0U}, {-1U});
    series_.flush(); // flush() actually reads the data
    return xyz_double;

  } else if (rcomp.getDatatype() == openPMD::Datatype::FLOAT) {
    // create VTK buffer
    vtkFloatArray *xyz_float = vtkFloatArray::New();
    xyz_float->SetNumberOfComponents(1);
    xyz_float->SetNumberOfTuples(nelem);
    float *xyz_ptr = xyz_float->GetPointer(0);

    // set offset and extent are set to read the full array
    rcomp.loadChunkRaw(xyz_ptr, {0U}, {-1U});
    series_.flush(); // flush() actually reads the data
    return xyz_float;

  } else {
    debug5 << "[openpmd-api-plugin] "
           << "Unknown openPMD Datatype: " << rcomp.getDatatype() << "\n";
    return 0;
  }

  return 0;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVectorVar(int timestate,
                                                 const char *varname) {
  return 0;
}
