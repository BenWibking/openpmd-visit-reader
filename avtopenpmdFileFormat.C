// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtopenpmdFileFormat.C
// ****************************************************************************

#include <iostream>
#include <string>

#include <avtDatabaseMetaData.h>
#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <openPMD/openPMD.hpp>

#include <DBOptionsAttributes.h>
#include <Expression.h>
#include <InvalidVariableException.h>

#include "avtopenpmdFileFormat.h"

// ****************************************************************************
//  Method: avtopenpmdFileFormat constructor
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

avtopenpmdFileFormat::avtopenpmdFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1) {
  //
  // initialize an openPMD::series object
  //

  // read incomplete filepath string from file 'filename'
  std::string opmd_filestring;
  {
    std::ifstream file(filename);
    std::getline(file, opmd_filestring);
    file.close();
  }

  // construct complete filepath
  std::filesystem::path p(filename);
  std::string os_pathsep = "/";
  std::string parent_path = p.parent_path();
  std::string opmd_filepath = parent_path + os_pathsep + opmd_filestring;
  std::cout << "Reading OpenPMD series: " << opmd_filepath << "\n";

  // open openPMD series
  series_ = openPMD::Series(opmd_filepath, openPMD::Access::READ_ONLY);
  std::cout << "This file uses openPMD-standard version " << series_.openPMD()
            << '\n';

#if 0
  // read attributes
  std::cout << "Attributes in the root dataset:\n";
  for (auto const &val : series_.attributes()) {
    std::cout << '\t' << val << '\n';
  }
  std::cout << '\n';
#endif

  // read iteration count
  std::cout << "This file contains " << series_.iterations.size()
            << " iterations:";
  iterationIndex_ = std::vector<unsigned long long>(series_.iterations.size());

  // save map from timeState to iteration index
  // NOTE: openPMD's iteration index can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  int timeState = 0;
  for (auto const &iter : series_.iterations) {
    std::cout << "\n\t" << iter.first;
    iterationIndex_.at(timeState) = iter.first;
    timeState++;
  }
  std::cout << '\n';
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

int avtopenpmdFileFormat::GetNTimesteps(void) {
  return series_.iterations.size();
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::FreeUpResources(void) {}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md,
                                                    int timeState) {
  // NOTE: openPMD's iteration index 'iter' can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  unsigned long long iter = iterationIndex_.at(timeState);
  std::cout << "Populating database metadata for iteration " << iter << "\n";

  // open openPMD::Iteration 'iter'
  openPMD::Iteration i = series_.iterations[iter];

  // loop over openPMD::Mesh objects
  std::cout << "Iteration " << iter << " contains " << i.meshes.size()
            << " meshes:\n";

  for (auto const &mesh_tuple : i.meshes) {
    std::string meshname = mesh_tuple.first;
    openPMD::Mesh const &mesh = mesh_tuple.second;
    std::cout << "Reading mesh " << meshname << "\n";

    std::string meshPrefix = std::to_string(iter) + '.' + meshname;
    std::string axisLabels = "";
    for (auto const &val : mesh.axisLabels())
      axisLabels += val + ", ";
    std::string gridSpacing = "";
    for (auto const &val : mesh.gridSpacing<float>())
      gridSpacing += std::to_string(val) + ", ";
    std::string gridGlobalOffset = "";
    for (auto const &val : mesh.gridGlobalOffset())
      gridGlobalOffset += std::to_string(val) + ", ";
    std::string unitDimension = "";
    for (auto const &val : mesh.unitDimension()) {
      unitDimension += std::to_string(val) + ", ";
    }

    std::cout << meshPrefix << ".geometry - " << mesh.geometry() << '\n'
              << meshPrefix << ".dataOrder - " << mesh.dataOrder() << '\n'
              << meshPrefix << ".axisLabels - " << axisLabels << '\n'
              << meshPrefix << ".gridSpacing - " << gridSpacing << '\n'
              << meshPrefix << ".gridGlobalOffset - " << gridGlobalOffset
              << '\n'
              << meshPrefix << ".gridUnitSI - " << mesh.gridUnitSI() << '\n'
              << meshPrefix << ".unitDimension - " << unitDimension << '\n'
              << meshPrefix << ".timeOffset - " << mesh.timeOffset<float>()
              << '\n'
              << '\n';

    avtMeshType mt = AVT_RECTILINEAR_MESH;
    int nblocks = 1; // <-- this must be 1 for MTSD
    int block_origin = 0;
    int spatial_dimension = mesh.axisLabels().size();
    int topological_dimension = spatial_dimension;
    double *extents = NULL; // TODO: add extents for mesh

    AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
                      spatial_dimension, topological_dimension);

    // Each openPMD::Mesh may contain one or more openPMD::MeshRecordComponent
    // A MeshRecordComponent is either i) a scalar, or ii) a vector component

    if (mesh.scalar()) { // this openPMD::Mesh contains only one
                         // MeshRecordComponent
      // when there is only one MeshRecordComponent, the name of the variable
      // should be the same as the Mesh
      std::cout << "Adding scalar variable " << meshname << "\n";

      // TODO: read the centering from attributes
      // NOTE: OpenPMD allows for arbitrary centering. Components can be face-
      // or edge-centered! VisIt centerings: AVT_NODECENT, AVT_ZONECENT,
      // AVT_UNKNOWN_CENT
      avtCentering cent = AVT_ZONECENT;

      AddScalarVarToMetaData(md, meshname, meshname, cent);

    } else { // this openPMD::Mesh contains multiple MeshRecordComponent's
      // NOTE: this object MAY or MAY NOT make sense to treat as a vector.
      // It probably makes more sense to enroll multiple scalar variables, one per
      // MeshRecordComponent, and let the user create a vector with
      // expressions, if appropriate for the dataset.

      for (auto const &rc : mesh) {
        // when there are multiple components, we create a hierarchical dataset
        std::string varname = meshname + std::string("/") + rc.first;
        std::cout << "Adding scalar variable " << varname << "\n";

        // TODO: read the centering from attributes
        // NOTE: OpenPMD allows for arbitrary centering. Components can be face-
        // or edge-centered! VisIt centerings: AVT_NODECENT, AVT_ZONECENT,
        // AVT_UNKNOWN_CENT
        avtCentering cent = AVT_ZONECENT;

        AddScalarVarToMetaData(md, varname, meshname, cent);
      }
    }
  }
  std::cout << '\n' << '\n';
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and
//                  N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataSet *avtopenpmdFileFormat::GetMesh(int timestate, const char *meshname) {
  //    YOU MUST IMPLEMENT THIS
  return 0;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVar(int timestate, const char *varname) {
  //    YOU MUST IMPLEMENT THIS
  return 0;

  //
  // If you do have a scalar variable, here is some code that may be helpful.
  //
  // int ntuples = XXX; // this is the number of entries in the variable.
  // vtkFloatArray *rv = vtkFloatArray::New();
  // rv->SetNumberOfTuples(ntuples);
  // for (int i = 0 ; i < ntuples ; i++)
  // {
  //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
  // }
  //
  // return rv;
  //
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVectorVar(int timestate,
                                                 const char *varname) {
  return 0;
}
