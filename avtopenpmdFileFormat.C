// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtopenpmdFileFormat.C
// ****************************************************************************

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <iostream>
#include <stdexcept>
#include <string>

#include <avtDatabaseMetaData.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>

#include <openPMD/openPMD.hpp>

#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include <Expression.h>
#include <InvalidVariableException.h>

#include "avtopenpmdFileFormat.h"
#include "dataLayoutTransform.h"

// ****************************************************************************
//  Method: avtopenpmdFileFormat constructor
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

avtopenpmdFileFormat::avtopenpmdFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1) {
  //
  // initialize an openPMD::series object
  //

  // read incomplete filepath string from file 'filename'
  std::string opmd_filestring;
  std::string opmd_overrideMeshAxisLabels;
  std::string opmd_overrideParticleAxisLabels;

  {
    std::ifstream file(filename);

    // get file string
    std::getline(file, opmd_filestring);

    // if it exists, get overrideMeshAxisLabels
    std::getline(file, opmd_overrideMeshAxisLabels);
    if (opmd_overrideMeshAxisLabels != "") {
      doOverrideMeshAxisOrder_ = true;
      auto iss = std::istringstream{opmd_overrideMeshAxisLabels};
      auto str = std::string{};
      while (iss >> str) {
        overrideMeshAxisLabels_.push_back(str);
      }
    }

    // if it exists, get overrideParticleAxisLabels
    std::getline(file, opmd_overrideParticleAxisLabels);
    if (opmd_overrideParticleAxisLabels != "") {
      doOverrideParticleAxisOrder_ = true;
      auto iss = std::istringstream{opmd_overrideParticleAxisLabels};
      auto str = std::string{};
      while (iss >> str) {
        overrideParticleAxisLabels_.push_back(str);
      }
    }

    // close file
    file.close();
  }

  // construct complete filepath
  std::filesystem::path p(filename);
  std::string os_pathsep = "/";
  std::string parent_path = p.parent_path();
  std::string opmd_filepath = parent_path + os_pathsep + opmd_filestring;
  debug5 << "[openpmd-api-plugin] "
         << "Reading OpenPMD series: " << opmd_filepath << "\n";

  // open openPMD series
  series_ = openPMD::Series(opmd_filepath, openPMD::Access::READ_ONLY);
  debug5 << "[openpmd-api-plugin] "
         << "This file uses openPMD-standard version " << series_.openPMD()
         << '\n';

  // read iteration count
  debug5 << "[openpmd-api-plugin] "
         << "This file contains " << series_.snapshots().size()
         << " iterations:";
  iterationIndex_ = std::vector<unsigned long long>(series_.snapshots().size());

  // save map from timeState to iteration index
  // NOTE: openPMD's iteration index can be an arbitrary number, and can
  // skip numbers. For instance, a dataset can have iterations = {550, 600}.
  int timeState = 0;
  for (auto const &iter : series_.snapshots()) {
    debug5 << "\n\t" << iter.first;
    iterationIndex_.at(timeState) = iter.first;
    timeState++;
  }
  debug5 << '\n';
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

int avtopenpmdFileFormat::GetNTimesteps(void) {
  return series_.snapshots().size();
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::FreeUpResources(void) {}

void avtopenpmdFileFormat::ReadFieldMetaData(avtDatabaseMetaData *md,
                                             openPMD::Iteration const &i) {
  // NOTE: a good reference for understanding how to read OpenPMD files is:
  // https://github.com/openPMD/openPMD-api/blob/dev/examples/6_dump_filebased_series.cpp

  // loop over openPMD::Mesh objects
  debug5 << "[openpmd-api-plugin] "
         << "This iteration contains " << i.meshes.size() << " meshes:\n";

  for (auto const &mesh_tuple : i.meshes) {
    std::string openpmd_meshname = mesh_tuple.first;
    std::string visit_meshname = openpmd_meshname + "_mesh";

    openPMD::Mesh mesh = mesh_tuple.second;
    debug5 << "[openpmd-api-plugin] "
           << "Reading mesh " << openpmd_meshname << "\n";

    avtMeshType mt = AVT_RECTILINEAR_MESH;
    int nblocks = 1; // <-- this must be 1 for MTSD
    int block_origin = 0;
    int spatial_dimension = 3;
    int topological_dimension = mesh.axisLabels().size();
    double *extents = NULL;

    meshMap_[visit_meshname] = std::tuple(DatasetType::Field, openpmd_meshname);
    AddMeshToMetaData(md, visit_meshname, mt, extents, nblocks, block_origin,
                      spatial_dimension, topological_dimension);

    // Each openPMD::Mesh may contain one or more openPMD::MeshRecordComponent
    // A MeshRecordComponent is either i) a scalar, or ii) a vector component

    if (mesh.scalar()) {
      // this openPMD::Mesh contains only one MeshRecordComponent when there
      // is only one MeshRecordComponent, the name of the variable should be
      // the same as the Mesh
      std::string varname = openpmd_meshname;

      // read the element centering
      avtCentering cent = GetCenteringType<openPMD::Mesh>(mesh);

      // add var
      if (cent != AVT_UNKNOWN_CENT) {
        debug5 << "[openpmd-api-plugin] "
               << "Adding scalar variable " << varname << "\n";
        std::string openpmd_compname = openPMD::MeshRecordComponent::SCALAR;
        varMap_[varname] = std::tuple(openpmd_meshname, openpmd_compname);
        AddScalarVarToMetaData(md, varname, visit_meshname, cent);
      } else {
        debug5 << "[openpmd-api-plugin] "
               << "Var " << varname
               << " is not cell/node-centered, skipping.\n";
      }
    } else { // this openPMD::Mesh contains multiple 'MeshRecordComponent's
      // It probably makes more sense to enroll multiple scalar variables, one
      // per MeshRecordComponent, and let the user create a vector with
      // expressions, if appropriate for the dataset.

      for (auto const &rc : mesh) {
        // when there are multiple components, we create a hierarchical
        // dataset
        std::string openpmd_compname = rc.first;
        std::string varname =
            openpmd_meshname + std::string("/") + openpmd_compname;

        // read the element centering
        avtCentering cent =
            GetCenteringType<openPMD::MeshRecordComponent>(rc.second);

        // add var
        if (cent != AVT_UNKNOWN_CENT) {
          debug5 << "[openpmd-api-plugin] "
                 << "Adding scalar variable " << varname << "\n";
          varMap_[varname] = std::tuple(openpmd_meshname, openpmd_compname);
          AddScalarVarToMetaData(md, varname, visit_meshname, cent);
        } else {
          debug5 << "[openpmd-api-plugin] "
                 << "Var " << varname
                 << " is not cell/node-centered, skipping.\n";
        }
      }
    }
  }
  debug5 << '\n' << '\n';
}

void avtopenpmdFileFormat::ReadParticleMetaData(avtDatabaseMetaData *md,
                                                openPMD::Iteration const &i) {
  // NOTE: a good reference for understanding how to read OpenPMD files is:
  // https://github.com/openPMD/openPMD-api/blob/dev/examples/6_dump_filebased_series.cpp

  // loop over openPMD::ParticleSpecies objects
  debug5 << "[openpmd-api-plugin] "
         << "This iteration contains " << i.particles.size()
         << " particle species:\n";

  for (auto const &particle_tuple : i.particles) {
    std::string openpmd_speciesname = particle_tuple.first;
    std::string visit_meshname = openpmd_speciesname + "_particles";

    openPMD::ParticleSpecies species = particle_tuple.second;
    debug5 << "[openpmd-api-plugin] "
           << "Reading particle species " << openpmd_speciesname << "\n";

    meshMap_[visit_meshname] =
        std::tuple(DatasetType::ParticleSpecies, openpmd_speciesname);
    avtMeshMetaData *mmd =
        new avtMeshMetaData(visit_meshname, 1, 0, 0, 0, 3, 1, AVT_POINT_MESH);
    mmd->nodesAreCritical = true;
    md->Add(mmd);
  }
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

void avtopenpmdFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md,
                                                    int timeState) {
  // NOTE: openPMD's iteration index 'iter' can be an arbitrary number, and
  // can skip numbers. For instance, a dataset can have iterations = {550,
  // 600}.
  unsigned long long iterIdx = iterationIndex_.at(timeState);
  debug5 << "[openpmd-api-plugin] "
         << "PopulateDatabaseMetaData() for iteration " << iterIdx << "\n";

  // open openPMD::Iteration 'iter'
  openPMD::Iteration iter = series_.snapshots()[iterIdx];

  // read fields
  ReadFieldMetaData(md, iter);

  // read particles
  ReadParticleMetaData(md, iter);
}

vtkDataSet *avtopenpmdFileFormat::GetMeshField(openPMD::Iteration i,
                                               std::string const &meshname) {
  // open openPMD::Mesh 'meshname'
  openPMD::Mesh mesh = i.meshes[meshname];

  // check that this is a cartesian mesh
  if (mesh.geometry() != openPMD::Mesh::Geometry::cartesian) {
    debug5 << "[openpmd-api-plugin] "
           << "Unknown openPMD::Mesh geometry. Must be cartesian!\n";
    return 0;
  }

  // openPMD geometry
  const int ndims = mesh.axisLabels().size(); // topological dimension
  const GeometryData geom = GetGeometryXYZ(mesh, true);
  double gridUnitSI =
      mesh.gridUnitSI(); // gridUnitSI scales the grid dimensions

  // debugging
  for (int idim = 0; idim < 3; ++idim) {
    debug5 << "gridExtent[" << idim << "] = " << geom.extent[idim] << '\n';
    debug5 << "gridSpacing[" << idim << "] = " << geom.gridSpacing[idim]
           << '\n';
    debug5 << "gridOrigin[" << idim << "] = " << geom.gridOrigin[idim] << '\n';
  }
  debug5 << '\n';

  // VTK geometry
  double origin[3] = {0, 0, 0};  // position x0, y0, z0
  double spacing[3] = {0, 0, 0}; // dx, dy, dz
  int dims[3] = {1, 1, 1};       // number of cells + 1
  avtCentering cent = GetCenteringType<openPMD::Mesh>(mesh);

  for (int idim = 0; idim < 3; ++idim) {
    // rescale code units to SI units
    origin[idim] = gridUnitSI * geom.gridOrigin[idim];
    spacing[idim] = gridUnitSI * geom.gridSpacing[idim];

    if (cent == AVT_ZONECENT) {
      dims[idim] = static_cast<int>(geom.extent[idim]) + 1;
    } else if (cent == AVT_NODECENT) {
      dims[idim] = static_cast<int>(geom.extent[idim]);
    }
  }

  // TODO(benwibking): loop over chunks and create separate vtkUniformGrids
  // for each chunk and assemble into an AMR mesh. This is necessary for files
  // with sparse grids (also used for AMR datasets).

  vtkFloatArray *coords[3];
  for (int idim = 0; idim < 3; ++idim) {
    coords[idim] = vtkFloatArray::New();
    // initialize with null values
    coords[idim]->SetNumberOfTuples(1);
    coords[idim]->SetComponent(0, 0, 0.);
  }

  // loop over real dimensions
  for (int idim = 0; idim < 3; ++idim) {
    coords[idim]->SetNumberOfTuples(dims[idim]);
    float *array = static_cast<float *>(coords[idim]->GetVoidPointer(0));
    // set rectilinear coordinates at nodes of grid
    for (int idx = 0; idx <= dims[idim]; ++idx) {
      array[idx] = idx * spacing[idim] + origin[idim];
    }
  }

  vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
  rgrid->SetDimensions(dims);
  rgrid->SetXCoordinates(coords[0]);
  rgrid->SetYCoordinates(coords[1]);
  rgrid->SetZCoordinates(coords[2]);

  for (int idim = 0; idim < 3; ++idim) {
    coords[idim]->Delete();
  }

  return rgrid;
}

vtkDataSet *
avtopenpmdFileFormat::GetMeshParticles(openPMD::Iteration i,
                                       std::string const &meshname) {
  // open openPMD::ParticleSpecies 'meshname'
  openPMD::ParticleSpecies species = i.particles[meshname];

  // read particle positions and particle offsets, and their units

  // NOTE: particle position/offsets can by any of: float, double, int32,
  // uint32, int64, or uint64! (offsets are more likely to be integer types)

  // TODO(benwibking): use std::visit to handle all of these

  std::vector<double> x;
  std::vector<double> y;
  std::vector<double> z;
  double unitSI_x{1};
  double unitSI_y{1};
  double unitSI_z{1};

  std::vector<double> xoff;
  std::vector<double> yoff;
  std::vector<double> zoff;
  double unitSI_xoff{1};
  double unitSI_yoff{1};
  double unitSI_zoff{1};

  auto array_iter = {std::tuple("x", std::ref(x), std::ref(unitSI_x),
                                std::ref(xoff), std::ref(unitSI_xoff)),
                     std::tuple("y", std::ref(y), std::ref(unitSI_y),
                                std::ref(yoff), std::ref(unitSI_yoff)),
                     std::tuple("z", std::ref(z), std::ref(unitSI_z),
                                std::ref(zoff), std::ref(unitSI_zoff))};

  for (auto [comp, pos, pos_unit, offset, offset_unit] : array_iter) {
    // queue reading positions
    {
      std::string full_recordname = "position/" + std::string(comp);
      try {
        openPMD::RecordComponent rc = species["position"][comp];
        std::vector<uint64_t> extent = rc.getExtent();
        assert(extent.size() == 1);
        pos.get().resize(extent[0]);
        rc.loadChunkRaw(pos.get().data(), {0U}, {-1U});
        debug5 << "Reading " << full_recordname << " with extent " << extent[0]
               << ".\n";
      } catch (std::out_of_range) {
        debug5 << "[openpmd-api-plugin] " << full_recordname
               << " does not exist!\n";
      }
    }
    // queue reading offsets
    {
      std::string full_recordname = "positionOffset/" + std::string(comp);
      try {
        openPMD::RecordComponent rc_offset = species["positionOffset"][comp];
        std::vector<uint64_t> extent = rc_offset.getExtent();
        assert(extent.size() == 1);
        offset.get().resize(extent[0]);
        rc_offset.loadChunkRaw(offset.get().data(), {0U}, {-1U});
        debug5 << "Reading " << full_recordname << " with extent " << extent[0]
               << ".\n";
      } catch (std::out_of_range) {
        debug5 << "[openpmd-api-plugin] " << full_recordname
               << " does not exist!\n";
      }
    }
  }

  series_.flush(); // flush() actually reads the data (and unitSI!)

  for (auto [comp, pos, pos_unit, offset, offset_unit] : array_iter) {
    // read positions unitSI
    {
      openPMD::RecordComponent rc = species["position"][comp];
      pos_unit.get() = rc.unitSI();
      debug5 << "unitSI_" << comp << " = " << pos_unit.get() << '\n';
    }
    // read offsets unitSI
    {
      openPMD::RecordComponent rc_offset = species["positionOffset"][comp];
      offset_unit.get() = rc_offset.unitSI();
      debug5 << "unitSI_" << comp << "off = " << offset_unit.get() << '\n';
    }
  }

  // check that data is sane
  auto all_equal = [](auto v1, auto v2, auto v3) constexpr -> bool {
    return (v1 == v2) && (v2 == v3);
  };

  if (!all_equal(x.size(), y.size(), z.size())) {
    debug5 << "[openpmd-api-plugin] x.size() == " << x.size() << '\n';
    debug5 << "[openpmd-api-plugin] y.size() == " << y.size() << '\n';
    debug5 << "[openpmd-api-plugin] z.size() == " << z.size() << '\n';
    debug5 << "[openpmd-api-plugin] Particle position data is not consistent! "
              "Can't read it.\n";
    return 0;
  }

  if (!all_equal(xoff.size(), yoff.size(), zoff.size())) {
    debug5 << "[openpmd-api-plugin] xoff.size() == " << xoff.size() << '\n';
    debug5 << "[openpmd-api-plugin] yoff.size() == " << yoff.size() << '\n';
    debug5 << "[openpmd-api-plugin] zoff.size() == " << zoff.size() << '\n';
    debug5 << "[openpmd-api-plugin] Particle positionOffset data is not "
              "consistent! Can't read it.\n";
    return 0;
  }

  if (x.size() != xoff.size()) {
    debug5 << "[openpmd-api-plugin] Particles have size " << x.size()
           << "but offsets have size " << xoff.size()
           << ". Can't read particles!\n";
    return 0;
  }

  vtkPolyData *pd = vtkPolyData::New();
  vtkPoints *pts = vtkPoints::New();
  debug5 << "Creating vtkPoints of size = " << x.size() << '\n';
  pts->SetNumberOfPoints(x.size());
  pd->SetPoints(pts);
  pts->Delete();

  // get transpose
  std::vector<int> particleCompTranspose;
  if (doOverrideParticleAxisOrder_) {
    particleCompTranspose =
        GetAxisTranspose({"x", "y", "z"}, overrideParticleAxisLabels_);
  }

  for (int j = 0; j < x.size(); j++) {
    // rescale code units to SI units
    // dimensions could be extremely small or large, so compute double
    double xp = unitSI_x * x.at(j) + unitSI_xoff * xoff.at(j);
    double yp = unitSI_y * y.at(j) + unitSI_yoff * yoff.at(j);
    double zp = unitSI_z * z.at(j) + unitSI_zoff * zoff.at(j);

    if (!doOverrideParticleAxisOrder_) {
      pts->SetPoint(j, xp, yp, zp);
    } else {
      // re-order particle axes for debugging data layout issues
      std::vector<double> p{xp, yp, zp};
      TransposeVector(p, particleCompTranspose);
      pts->SetPoint(j, p[0], p[1], p[2]);
    }
  }

  vtkCellArray *verts = vtkCellArray::New();
  pd->SetVerts(verts);
  verts->Delete();

  for (int k = 0; k < x.size(); k++) {
    verts->InsertNextCell(1);
    verts->InsertCellPoint(k);
  }

  return pd;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and
//                  N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataSet *avtopenpmdFileFormat::GetMesh(int timeState,
                                          const char *visit_meshname) {
  // get actual iteration index
  unsigned long long iter = iterationIndex_.at(timeState);

  debug5 << "[openpmd-api-plugin] "
         << "GetMesh() for iteration " << iter << " and VisIt mesh "
         << visit_meshname << "\n";

  // open openPMD::Iteration 'iter'
  openPMD::Iteration i = series_.snapshots()[iter];

  // get actual meshname
  auto [dataset_type, meshname] = meshMap_[visit_meshname];

  if (dataset_type == DatasetType::Field) {
    return GetMeshField(i, meshname);
  } else if (dataset_type == DatasetType::ParticleSpecies) {
    return GetMeshParticles(i, meshname);
  }

  return 0;
}

GeometryData avtopenpmdFileFormat::GetGeometry3D(openPMD::Mesh const &mesh,
                                                 bool insertMissingAxes) {
  // get dataOrder
  auto dataOrder = mesh.dataOrder();

  // get axis labels
  std::vector<std::string> axisLabels = mesh.axisLabels();
  if (doOverrideMeshAxisOrder_) {
    // for debugging
    debug5 << "Overriding Mesh axis labels. As-written axis labels: ";
    for (auto label : axisLabels) {
      debug5 << label << " ";
    }
    debug5 << '\n';

    axisLabels = overrideMeshAxisLabels_; // must be the same size as original
                                          // axisLabels!
    debug5 << "\tNew axis labels: ";
    for (auto label : axisLabels) {
      debug5 << label << " ";
    }
    debug5 << '\n';
  }

  // get array extents
  auto extent = mesh.getExtent();

  // get grid spacing
  std::vector<double> gridSpacing = mesh.gridSpacing<double>();
  // get grid origin
  std::vector<double> gridOrigin = mesh.gridGlobalOffset();

  // reverse ordering if mesh.DataOrder() == DataOrder::F
  if (dataOrder == openPMD::Mesh::DataOrder::F) {
    std::reverse(axisLabels.begin(), axisLabels.end());
    std::reverse(extent.begin(), extent.end());
    std::reverse(gridSpacing.begin(), gridSpacing.end());
    std::reverse(gridOrigin.begin(), gridOrigin.end());
  }

  if (insertMissingAxes) {
    // add any missing axis labels at the *beginning* with extent 1
    std::vector<std::string> canonicalAxes = {
        std::string("z"), std::string("y"), std::string("x")};
    for (auto const &axis : canonicalAxes) {
      if (std::find(axisLabels.begin(), axisLabels.end(), axis) ==
          axisLabels.end()) {
        axisLabels.insert(axisLabels.begin(), axis);
        extent.insert(extent.begin(), 1);
        gridSpacing.insert(gridSpacing.begin(), 0);
        gridOrigin.insert(gridOrigin.begin(), 0);
      }
    }
  }

  GeometryData geom;
  geom.axisLabels = axisLabels;
  geom.extent = extent;
  geom.gridOrigin = gridOrigin;
  geom.gridSpacing = gridSpacing;
  return geom;
}

GeometryData avtopenpmdFileFormat::GetGeometryXYZ(openPMD::Mesh const &mesh,
                                                  bool insertMissingAxes) {
  GeometryData geom = GetGeometry3D(mesh, insertMissingAxes);

  // compute transposition of axisLabels -> {'x', 'y', 'z'}
  auto axisLabels = geom.axisLabels;
  auto transpose = GetAxisTranspose(axisLabels, {"x", "y", "z"});

  // transpose geometry data
  TransposeVector(geom.axisLabels, transpose);
  TransposeVector(geom.extent, transpose);
  TransposeVector(geom.gridSpacing, transpose);
  TransposeVector(geom.gridOrigin, transpose);

  // verify we did it right
  assert(geom.axisLabels[0] == std::string("x"));
  assert(geom.axisLabels[1] == std::string("y"));
  assert(geom.axisLabels[2] == std::string("z"));

  return geom;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVar(int timeState, const char *varname) {
  // get actual iteration index
  unsigned long long iter = iterationIndex_.at(timeState);

  // lookup openPMD mesh name and record component name from varname
  auto [meshname, rcname] = varMap_[varname];

  debug5 << "[openpmd-api-plugin] "
         << "GetVar() for iteration " << iter << " and var " << varname
         << std::endl;

  // open openPMD::Iteration 'iter' and openPMD::Mesh 'mesh'
  openPMD::Iteration i = series_.snapshots()[iter];
  openPMD::Mesh mesh = i.meshes[meshname];
  openPMD::MeshRecordComponent rcomp = mesh[rcname];

  // get number of elements
  uint64_t nelem = 1;
  for (auto const &nx : rcomp.getExtent()) {
    nelem *= nx;
  }

  if (rcomp.getDatatype() == openPMD::Datatype::DOUBLE) {
    // create VTK buffer
    vtkDoubleArray *xyz_double = vtkDoubleArray::New();
    xyz_double->SetNumberOfComponents(1);
    xyz_double->SetNumberOfTuples(nelem);
    double *xyz_ptr = xyz_double->GetPointer(0);

    // set offset and extent are set to read the full array
    rcomp.loadChunkRaw(xyz_ptr, {0U}, {-1U});
    series_.flush(); // flush() actually reads the data

    // rescale data to SI units
    // (rcomp.unitSI() must be read *after* flush!)
    ScaleVarData<double>(xyz_ptr, nelem, rcomp.unitSI());

#if 0
    // transpose array if needed
    TransposeArray(xyz_ptr, mesh, rcomp);
#endif
    return xyz_double;

  } else if (rcomp.getDatatype() == openPMD::Datatype::FLOAT) {
    // create VTK buffer
    vtkFloatArray *xyz_float = vtkFloatArray::New();
    xyz_float->SetNumberOfComponents(1);
    xyz_float->SetNumberOfTuples(nelem);
    float *xyz_ptr = xyz_float->GetPointer(0);

    // set offset and extent are set to read the full array
    rcomp.loadChunkRaw(xyz_ptr, {0U}, {-1U});
    series_.flush(); // flush() actually reads the data

    // rescale data to SI units
    // (rcomp.unitSI() must be read *after* flush!)
    ScaleVarData<float>(xyz_ptr, nelem, rcomp.unitSI());

#if 0
    // transpose array if needed
    TransposeArray(xyz_ptr, mesh, rcomp);
#endif
    return xyz_float;
  } else {
    debug5 << "[openpmd-api-plugin] "
           << "Unknown openPMD Datatype: " << rcomp.getDatatype() << "\n";
    return 0;
  }

  return 0;
}

// ****************************************************************************
//  Method: avtopenpmdFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

vtkDataArray *avtopenpmdFileFormat::GetVectorVar(int timestate,
                                                 const char *varname) {
  return 0;
}
