// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtopenpmdFileFormat.h
// ****************************************************************************

#ifndef AVT_openpmd_FILE_FORMAT_H
#define AVT_openpmd_FILE_FORMAT_H

#include <array>
#include <map>
#include <string>
#include <unordered_map>
#include <vector>

#include <openPMD/openPMD.hpp>

#include <DebugStream.h>
#include <avtMTMDFileFormat.h>
#include <avtTypes.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtStructuredDomainNesting.h>

struct GeometryData {
  std::vector<std::string> axisLabels;
  std::vector<uint64_t> extent;
  std::vector<double> gridSpacing;
  std::vector<double> gridOrigin;
};

// ****************************************************************************
//  Class: avtopenpmdFileFormat
//
//  Purpose:
//      Reads in openpmd files as a plugin to VisIt.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

struct PatchInfo {
  int level{0};
  openPMD::Offset offset{};
  openPMD::Extent extent{};
  std::string meshName;
  double origin[3]{0.0, 0.0, 0.0};
  double spacing[3]{0.0, 0.0, 0.0};
  avtCentering centering{AVT_UNKNOWN_CENT};
  int logicalLower[3]{0, 0, 0};
  int logicalUpper[3]{0, 0, 0};
};

struct MeshPatchHierarchy {
  std::vector<PatchInfo> patches;
  int numLevels{0};
  std::vector<std::array<int, 3>> levelRefinementRatios; // per level > 0
  std::vector<int> levelIdsPerPatch;      // size == patches, values in [0, numLevels)
  std::vector<int> groupIds;
  std::vector<std::string> blockNames;
  std::vector<int> levelValues;           // sorted unique level identifiers
  std::vector<std::vector<int>> patchesPerLevel;
  std::vector<std::array<double, 3>> levelCellSizes;
  bool metadataInitialized{false};
  int topologicalDim{0};
  int spatialDim{0};
};

class avtopenpmdFileFormat : public avtMTMDFileFormat {
public:
  avtopenpmdFileFormat(const char *);
  ~avtopenpmdFileFormat() override;

  //
  // This is used to return unconvention data -- ranging from material
  // information to information about block connectivity.
  //
  // virtual void      *GetAuxiliaryData(const char *var, int timestep,
  //                                     const char *type, void *args,
  //                                     DestructorFunction &);
  //

  //
  // If you know the times and cycle numbers, overload this function.
  // Otherwise, VisIt will make up some reasonable ones for you.
  //
  // virtual void        GetCycles(std::vector<int> &);
  // virtual void        GetTimes(std::vector<double> &);
  //

  int GetNTimesteps(void) override;

  const char *GetType(void) override { return "openpmd"; }
  void FreeUpResources(void) override;

  vtkDataSet *GetMesh(int, int, const char *) override;
  vtkDataArray *GetVar(int, int, const char *) override;
  vtkDataArray *GetVectorVar(int, int, const char *) override;

  enum class DatasetType { Field = 0, ParticleSpecies };

  // Order of transposes relative to the layout of data
  // For 3D data : in case of (z, y, x) ordering of axes
  const std::vector<int> _3d = {2, 1, 0};
  // For 2D data : in case of (z, x) ordering of axes
  const std::vector<int> _2d_xz = {1, 2, 0};
  // For 2D data : in case of (y, x) ordering of axes
  const std::vector<int> _2d_xy = {1, 0, 2};
  // For 1D data : in case data layout (z)
  const std::vector<int> _1d = {2, 1, 0};
  // identity transpose
  const std::vector<int> _identity = {0, 1, 2};

protected:
  // DATA MEMBERS
  openPMD::Series series_;
  std::vector<unsigned long long> iterationIndex_;
  std::unordered_map<std::string, std::tuple<std::string, std::string>>
      varMap_; // from VisIt varname, get VisIt mesh name and record component
  std::unordered_map<std::string, std::tuple<DatasetType, std::string>>
      meshMap_; // from VisIt mesh name, get openPMD mesh name AND DatasetType
  std::vector<std::unordered_map<std::string, MeshPatchHierarchy>>
      meshHierarchyCache_; // per timestep

  bool doOverrideMeshAxisOrder_{false};
  bool doOverrideParticleAxisOrder_{false};
  std::vector<std::string> overrideMeshAxisLabels_;
  std::vector<std::string> overrideParticleAxisLabels_;

  void PopulateDatabaseMetaData(avtDatabaseMetaData *, int) override;
  virtual void *GetAuxiliaryData(const char *var, int timestep, int domain,
                                 const char *type, void *args,
                                 DestructorFunction &) override;
  void BuildFieldHierarchy(avtDatabaseMetaData *md, openPMD::Iteration const &i,
                           int timeState);
  void BuildParticleMetaData(avtDatabaseMetaData *md,
                             openPMD::Iteration const &i);
  std::pair<std::string, int> ParseMeshLevel(std::string const &meshName) const;
  MeshPatchHierarchy CreateHierarchyForGroup(
      const std::string &visitMeshName,
      const std::vector<std::pair<int, std::string>> &levels,
      openPMD::Iteration const &iter);
  vtkDataSet *CreateRectilinearPatch(const PatchInfo &patch) const;
  vtkDataArray *LoadScalarPatchData(openPMD::Iteration const &iteration,
                                    const PatchInfo &patch,
                                    const std::string &component) const;
  vtkDataArray *LoadVectorPatchData(openPMD::Iteration const &iteration,
                                    const PatchInfo &patch,
                                    const std::vector<std::string> &components)
      const;
  avtStructuredDomainNesting *
  BuildDomainNesting(const MeshPatchHierarchy &hierarchy) const;
  avtStructuredDomainBoundaries *
  BuildDomainBoundaries(const MeshPatchHierarchy &hierarchy) const;

  template <typename T> static void ScaleVarData(T *xyz_ptr, size_t nelem,
                                                 T unitSI);

  template <typename T> avtCentering GetCenteringType(T const &mesh);

  GeometryData GetGeometry3D(openPMD::Mesh const &mesh,
                             bool insertMissingAxes = true);

  GeometryData GetGeometryXYZ(openPMD::Mesh const &mesh,
                              bool insertMissingAxes = true);

  std::vector<int>
  GetAxisTranspose(std::vector<std::string> const &axisLabelsSrc,
                   std::vector<std::string> const &axisLabelsDst);

  template <typename T>
  void TransposeVector(std::vector<T> &vec_to_transpose,
                       std::vector<int> const &transpose);

  template <typename T>
  void TransposeArray(T *data_ptr, openPMD::Mesh const &mesh,
                      openPMD::Mesh::MeshRecordComponent const &rcomp);
};

template <typename T>
avtCentering avtopenpmdFileFormat::GetCenteringType(T const &mesh) {
  // read the element centering
  std::vector<float> centering;
  try {
    centering = mesh.template position<float>();
  } catch (openPMD::Error) {
    debug5 << "[openpmd-api-plugin] "
           << "Can't read centering for mesh!\n";
    return AVT_UNKNOWN_CENT;
  }

  // cell-centered == {0.5, 0.5, 0.5}
  bool isCellCentered = true;
  for (int idim = 0; idim < centering.size(); idim++) {
    isCellCentered = (isCellCentered && (centering[idim] == 0.5));
  }

  // node-centered == {0, 0, 0}
  bool isNodeCentered = true;
  for (int idim = 0; idim < centering.size(); idim++) {
    isNodeCentered = (isNodeCentered && (centering[idim] == 0.));
  }

  if (isCellCentered) {
    debug5 << "[openpmd-api-plugin] "
           << "Mesh is cell-centered.\n";
    return AVT_ZONECENT;
  } else if (isNodeCentered) {
    debug5 << "[openpmd-api-plugin] "
           << "Mesh is node-centered.\n";
    return AVT_NODECENT;
  }

  // face-centered == {0, 0.5, 0.5}, etc.
  // edge-centered == {0, 0, 0.5}, etc.
  // However, all other centerings are unsupported by VisIt.
  debug5 << "[openpmd-api-plugin] "
         << "Mesh has unsupported centering.\n";
  return AVT_UNKNOWN_CENT;
}

template <typename T>
void avtopenpmdFileFormat::ScaleVarData(T *xyz_ptr, size_t nelem, T unitSI) {
  for (size_t idx = 0; idx < nelem; idx++) {
    xyz_ptr[idx] *= unitSI;
  }
}

#endif
