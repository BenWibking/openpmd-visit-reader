// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtopenpmdFileFormat.h
// ****************************************************************************

#ifndef AVT_openpmd_FILE_FORMAT_H
#define AVT_openpmd_FILE_FORMAT_H

#include <algorithm>
#include <array>
#include <cmath>
#include <map>
#include <string>
#include <tuple>
#include <unordered_map>
#include <vector>

#include <openPMD/openPMD.hpp>

#include <DebugStream.h>
#include <avtMTMDFileFormat.h>
#include <avtTypes.h>
#include <avtStructuredDomainNesting.h>
#include <avtLocalStructuredDomainBoundaries.h>

class vtkRectilinearGrid;

struct GeometryData {
  std::vector<std::string> axisLabels;
  std::vector<uint64_t> extent;
  std::vector<double> gridSpacing;
  std::vector<double> gridOrigin;
  std::vector<double> position;
  std::vector<std::string> storageAxisLabels;
  std::vector<int> storageToVtk;
};

// ****************************************************************************
//  Class: avtopenpmdFileFormat
//
//  Purpose:
//      Reads in openpmd files as a plugin to VisIt.
//
//  Programmer: benwibking -- generated by xml2avt
//  Creation:   Fri Dec 6 17:16:49 PST 2024
//
// ****************************************************************************

struct PatchInfo {
  int level{0};
  openPMD::Offset offset{};
  openPMD::Extent extent{};
  openPMD::Offset storageOffset{};
  openPMD::Extent storageExtent{};
  std::vector<uint64_t> storageOffsetCanonical;
  std::vector<uint64_t> storageExtentCanonical;
  std::vector<std::string> storageAxisLabels;
  std::array<int, 3> storageToVtk{{0, 1, 2}};
  openPMD::Mesh::DataOrder dataOrder{openPMD::Mesh::DataOrder::C};
  std::string meshName;
  double origin[3]{0.0, 0.0, 0.0};
  double spacing[3]{0.0, 0.0, 0.0};
  avtCentering centering{AVT_UNKNOWN_CENT};
  int logicalLower[3]{0, 0, 0};
  int logicalUpper[3]{0, 0, 0};
};

struct MeshPatchHierarchy {
  std::vector<PatchInfo> patches;
  int numLevels{0};
  std::vector<std::array<int, 3>> levelRefinementRatios; // per level > 0
  std::vector<int> levelIdsPerPatch;      // size == patches, values in [0, numLevels)
  std::vector<int> groupIds;
  std::vector<std::string> blockNames;
  std::vector<int> levelValues;           // sorted unique level identifiers
  std::vector<std::vector<int>> patchesPerLevel;
  std::vector<std::array<double, 3>> levelCellSizes;
  bool metadataInitialized{false};
  int topologicalDim{0};
  int spatialDim{0};
};

class avtopenpmdFileFormat : public avtMTMDFileFormat {
public:
  avtopenpmdFileFormat(const char *);
  ~avtopenpmdFileFormat() override;

  //
  // This is used to return unconvention data -- ranging from material
  // information to information about block connectivity.
  //
  // virtual void      *GetAuxiliaryData(const char *var, int timestep,
  //                                     const char *type, void *args,
  //                                     DestructorFunction &);
  //

  //
  // If you know the times and cycle numbers, overload this function.
  // Otherwise, VisIt will make up some reasonable ones for you.
  //
  // virtual void        GetCycles(std::vector<int> &);
  // virtual void        GetTimes(std::vector<double> &);
  //

  int GetNTimesteps(void) override;

  const char *GetType(void) override { return "openpmd"; }
  void FreeUpResources(void) override;

  vtkDataSet *GetMesh(int, int, const char *) override;
  vtkDataArray *GetVar(int, int, const char *) override;
  vtkDataArray *GetVectorVar(int, int, const char *) override;

  bool HasInvariantMetaData(void) const override { return false; }
  bool HasInvariantSIL(void) const override { return false; }

  enum class DatasetType { Field = 0, ParticleSpecies };

  // Order of transposes relative to the layout of data
  // For 3D data : in case of (z, y, x) ordering of axes
  const std::vector<int> _3d = {2, 1, 0};
protected:
  // DATA MEMBERS
  openPMD::Series series_;
  std::vector<unsigned long long> iterationIndex_;
  std::unordered_map<std::string, std::tuple<std::string, std::string>>
      varMap_; // from VisIt varname, get VisIt mesh name and record component
  std::unordered_map<std::string,
                     std::tuple<std::string, std::vector<std::string>>>
      vectorVarMap_; // from VisIt vector varname get mesh and component list
  std::unordered_map<std::string, std::tuple<DatasetType, std::string>>
      meshMap_; // from VisIt mesh name, get openPMD mesh name AND DatasetType
  std::vector<std::unordered_map<std::string, MeshPatchHierarchy>>
      meshHierarchyCache_; // per timestep

  bool doOverrideMeshAxisOrder_{false};
  bool doOverrideParticleAxisOrder_{false};
  bool doOverrideMeshDataOrder_{false};
  std::vector<std::string> overrideMeshAxisLabels_;
  std::vector<std::string> overrideParticleAxisLabels_;
  openPMD::Mesh::DataOrder overrideMeshDataOrder_{openPMD::Mesh::DataOrder::C};

  void PopulateDatabaseMetaData(avtDatabaseMetaData *, int) override;
  virtual void *GetAuxiliaryData(const char *var, int timestep, int domain,
                                 const char *type, void *args,
                                 DestructorFunction &) override;
  void EnsureHierarchyInitialized(int timeState);
  void PopulateHierarchyCache(openPMD::Iteration const &iteration,
                              int timeState, avtDatabaseMetaData *md);
  void BuildFieldHierarchy(avtDatabaseMetaData *md, openPMD::Iteration const &i,
                           int timeState);
  void BuildParticleMetaData(avtDatabaseMetaData *md,
                             openPMD::Iteration const &i);
  std::pair<std::string, int> ParseMeshLevel(std::string const &meshName) const;
  MeshPatchHierarchy CreateHierarchyForGroup(
      const std::string &visitMeshName,
      const std::vector<std::pair<int, std::string>> &levels,
      openPMD::Iteration const &iter);
  vtkDataSet *CreateRectilinearPatch(const PatchInfo &patch) const;
  vtkDataArray *LoadScalarPatchData(openPMD::Iteration const &iteration,
                                    const PatchInfo &patch,
                                    const std::string &component) const;
  vtkDataArray *LoadVectorPatchData(openPMD::Iteration const &iteration,
                                    const PatchInfo &patch,
                                    const std::vector<std::string> &components)
      const;
  avtStructuredDomainNesting *
  BuildDomainNesting(const MeshPatchHierarchy &hierarchy) const;
  avtLocalStructuredDomainBoundaryList *
  BuildDomainBoundaryList(const MeshPatchHierarchy &hierarchy, int domain) const;
  void AddGhostZonesForPatch(const MeshPatchHierarchy &hierarchy, int patchIdx,
                             vtkRectilinearGrid *grid) const;

  template <typename T> static void ScaleVarData(T *xyz_ptr, size_t nelem,
                                                 T unitSI);

  template <typename T> avtCentering GetCenteringType(T const &mesh);

  GeometryData
  GetGeometry3D(openPMD::Mesh const &mesh,
                openPMD::MeshRecordComponent const *representative = nullptr,
                bool insertMissingAxes = true);

  GeometryData
  GetGeometryXYZ(openPMD::Mesh const &mesh,
                 openPMD::MeshRecordComponent const *representative = nullptr,
                 bool insertMissingAxes = true);

  openPMD::Mesh::DataOrder
  GetEffectiveMeshDataOrder(openPMD::Mesh const &mesh) const;

  std::vector<int>
  GetAxisTranspose(std::vector<std::string> const &axisLabelsSrc,
                   std::vector<std::string> const &axisLabelsDst);

  template <typename T>
  void TransposeVector(std::vector<T> &vec_to_transpose,
                       std::vector<int> const &transpose);

  template <typename T>
  void RemapChunkToVTKLayout(T *data_ptr, size_t nelem,
                              const PatchInfo &patch) const;
};

template <typename T>
avtCentering avtopenpmdFileFormat::GetCenteringType(T const &mesh) {
  // read the element centering
  std::vector<float> centering;
  try {
    centering = mesh.template position<float>();
  } catch (openPMD::Error) {
    debug5 << "[openpmd-api-plugin] "
           << "Can't read centering for mesh!\n";
    return AVT_UNKNOWN_CENT;
  }

  if (centering.empty()) {
    debug5 << "[openpmd-api-plugin] Mesh centering metadata empty.\n";
    return AVT_UNKNOWN_CENT;
  }

  auto isApproximately = [&](float expected) {
    for (float value : centering) {
      if (std::abs(value - expected) > 1e-5f) {
        return false;
      }
    }
    return true;
  };

  if (isApproximately(0.5f)) {
    debug5 << "[openpmd-api-plugin] Mesh is cell-centered.\n";
    return AVT_ZONECENT;
  }

  if (isApproximately(0.0f)) {
    debug5 << "[openpmd-api-plugin] Mesh is node-centered.\n";
    return AVT_NODECENT;
  }

  // face-centered == {0, 0.5, 0.5}, etc.
  // edge-centered == {0, 0, 0.5}, etc.
  // However, all other centerings are unsupported by VisIt.
  debug5 << "[openpmd-api-plugin] "
         << "Mesh has unsupported centering.\n";
  return AVT_UNKNOWN_CENT;
}

template <typename T>
void avtopenpmdFileFormat::ScaleVarData(T *xyz_ptr, size_t nelem, T unitSI) {
  for (size_t idx = 0; idx < nelem; idx++) {
    xyz_ptr[idx] *= unitSI;
  }
}

template <typename T>
void avtopenpmdFileFormat::TransposeVector(
    std::vector<T> &vec_to_transpose, std::vector<int> const &transpose) {
  const std::size_t srcSize = vec_to_transpose.size();
  const std::size_t permSize = transpose.size();

  if (srcSize == 0 || permSize == 0) {
    return;
  }

  if (srcSize != permSize) {
    debug5 << "[openpmd-api-plugin] TransposeVector size mismatch: values="
           << srcSize << " permutation=" << permSize << "\n";
  }

  std::vector<T> vec = vec_to_transpose;
  const std::size_t limit = std::min(srcSize, permSize);
  for (std::size_t i = 0; i < limit; ++i) {
    const int idx = transpose[i];
    if (idx < 0 || static_cast<std::size_t>(idx) >= srcSize) {
      debug5 << "[openpmd-api-plugin] TransposeVector index " << idx
             << " out of range for size " << srcSize << "\n";
      continue;
    }
    vec_to_transpose[i] = vec[static_cast<std::size_t>(idx)];
  }
}

template <typename T>
void avtopenpmdFileFormat::RemapChunkToVTKLayout(T *data_ptr, size_t nelem,
                                                 const PatchInfo &patch) const {
  if (data_ptr == nullptr || nelem == 0) {
    return;
  }

  const auto &storageDims = patch.storageExtentCanonical;
  const auto &storageToVtk = patch.storageToVtk;
  if (storageDims.empty()) {
    return;
  }

  bool requiresRemap = patch.dataOrder == openPMD::Mesh::DataOrder::F;
  for (int axis = 0; axis < 3; ++axis) {
    if (storageToVtk[axis] >= 0 && storageToVtk[axis] != axis) {
      requiresRemap = true;
      break;
    }
  }

  if (!requiresRemap) {
    return;
  }

  const size_t rank = storageDims.size();
  if (rank == 0) {
    return;
  }

  std::vector<size_t> storageDimSizes(rank, 1);
  for (size_t idx = 0; idx < rank; ++idx) {
    storageDimSizes[idx] = static_cast<size_t>(storageDims[idx] == 0 ? 1 : storageDims[idx]);
  }

  size_t storageCount = 1;
  for (auto dim : storageDimSizes) {
    storageCount *= dim;
  }
  if (storageCount == 0) {
    return;
  }
  storageCount = std::min(storageCount, nelem);

  std::array<size_t, 3> vtkDims{1, 1, 1};
  for (size_t axis = 0; axis < std::min<size_t>(3, patch.extent.size()); ++axis) {
    vtkDims[axis] = static_cast<size_t>(patch.extent[axis] == 0 ? 1 : patch.extent[axis]);
  }

  std::array<size_t, 3> validMax{1, 1, 1};
  for (int axis = 0; axis < 3; ++axis) {
    int storageIndex = storageToVtk[axis];
    size_t dimValue = vtkDims[axis];
    if (storageIndex >= 0 &&
        storageIndex < static_cast<int>(storageDimSizes.size())) {
      dimValue = storageDimSizes[static_cast<size_t>(storageIndex)];
    }
    if (dimValue == 0) {
      dimValue = 1;
    }
    validMax[static_cast<size_t>(axis)] = dimValue;
  }

  std::vector<size_t> storageStrides(rank, 1);
  if (patch.dataOrder == openPMD::Mesh::DataOrder::F) {
    for (size_t idx = 1; idx < rank; ++idx) {
      storageStrides[idx] = storageStrides[idx - 1] * storageDimSizes[idx - 1];
    }
  } else {
    if (rank >= 1) {
      storageStrides[rank - 1] = 1;
      for (size_t idx = rank - 1; idx > 0; --idx) {
        storageStrides[idx - 1] = storageStrides[idx] * storageDimSizes[idx];
      }
    }
  }

  std::vector<T> copy(data_ptr, data_ptr + storageCount);
  std::vector<size_t> coordsStorage(rank, 0);
  std::array<size_t, 3> coordsVtk{0, 0, 0};

  for (size_t z = 0; z < vtkDims[2]; ++z) {
    if (z >= validMax[2]) {
      continue;
    }
    coordsVtk[2] = z;
    for (size_t y = 0; y < vtkDims[1]; ++y) {
      if (y >= validMax[1]) {
        continue;
      }
      coordsVtk[1] = y;
      for (size_t x = 0; x < vtkDims[0]; ++x) {
        if (x >= validMax[0]) {
          continue;
        }
        coordsVtk[0] = x;
        std::fill(coordsStorage.begin(), coordsStorage.end(), 0);
        for (size_t axis = 0; axis < 3; ++axis) {
          int storageIndex = storageToVtk[axis];
          if (storageIndex < 0 ||
              storageIndex >= static_cast<int>(coordsStorage.size())) {
            continue;
          }
          coordsStorage[static_cast<size_t>(storageIndex)] = coordsVtk[axis];
        }

        size_t storageIndexLinear = 0;
        for (size_t axis = 0; axis < rank; ++axis) {
          storageIndexLinear += coordsStorage[axis] * storageStrides[axis];
        }
        if (storageIndexLinear >= storageCount) {
          continue;
        }

        size_t vtkIndex = x + vtkDims[0] * (y + vtkDims[1] * z);
        data_ptr[vtkIndex] = copy[storageIndexLinear];
      }
    }
  }
}

#endif
